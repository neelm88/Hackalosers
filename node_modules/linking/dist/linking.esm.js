function identity(it) {
  return it;
}

function classFactory(component) {
  return function (spec) {
    let ctor;
    ctor = identity(function () {});
    ctor.prototype = Object.assign(Object.create(component.prototype), spec, {
      constructor: ctor
    });
    return Object.assign(ctor, {
      displayName: spec.displayName
    });
  };
}

function flatDiff(a, b) {
  let keys;
  if (a === b) return false;
  if (typeof a !== "object" || typeof b !== "object") return true;
  keys = Object.keys(a);
  if (keys.length !== Object.keys(b).length) return true;
  return keys.some(function (it) {
    return a[it] !== b[it];
  });
}

let empty;
empty = {};

function name(it) {
  return it.displayName || it.name || it;
}

function pass(it) {
  return it;
}

function nested(store) {
  let listeners;
  listeners = new Set();
  return Object.assign({}, store, {
    subscribe: function (it) {
      listeners.add(it);
      return listeners.delete.bind(listeners, it);
    },
    notify: function () {
      return Array.from(listeners.keys()).map(function (it) {
        return it();
      });
    }
  });
}

function init(instance, select, merge, render) {
  let store, context, next, selected, changed, handleMount;
  store = instance.props.store || instance.context.store;
  context = {
    store: next = select !== pass ? nested(store) : store
  };
  selected = select(store.getState(), instance.props);
  changed = false;

  function handleChange(props = instance.props) {
    let prev;
    prev = selected;
    selected = select(store.getState(), props);
    return flatDiff(prev, selected) ? changed = true : next.notify();
  }

  function bindAction(createAction, props) {
    return function (event) {
      let action;
      action = (typeof createAction == "function" ? createAction(event, props, store.getState) : void 8) || createAction;
      return (typeof action.then == "function" ? action.then(store.dispatch) : void 8) || (action.type ? store.dispatch(action) : void 0);
    };
  }

  handleMount = select !== pass ? {
    componentDidMount: function () {
      instance.componentWillUnmount = store.subscribe(() => handleChange() && instance.setState(empty));
    }
  } : void 0;
  Object.assign(instance, handleMount, {
    getChildContext: function () {
      return context;
    },
    componentWillReceiveProps: function (it) {
      if (select !== pass) handleChange(it);
      changed || (changed = merge.length > 2 && flatDiff(instance.props, it));
    },
    shouldComponentUpdate: function () {
      return changed;
    },
    render: function () {
      changed = false;
      return render(merge(selected, bindAction, instance.props));
    }
  });
}

function chain(select, merge, render) {
  return {
    displayName: name(render),
    componentWillMount: function () {
      init(this, select, merge, render);
    },
    render: pass
  };
}

function link({
  Component,
  propTypes,
  createClass = classFactory(Component)
}) {
  let types, contextTypes, that;
  types = (that = propTypes != null ? propTypes.any : void 8) ? (contextTypes = {
    store: that
  }, {
    contextTypes,
    childContextTypes: contextTypes
  }) : void 0;
  return function (render, select = pass, merge = pass) {
    let linking;
    linking = chain(select, merge, render);
    return createClass(Object.assign({}, types, linking));
  };
}

function handleActions(handlers, defaultState = {}) {
  return function (state, {
    type,
    payload
  }) {
    let that;
    return (that = typeof handlers[type] == "function" ? handlers[type](state, payload) : void 8) ? Object.assign({}, state, that) : state || defaultState;
  };
}

function renderEmpty() {
  return "";
}

function hasChanges(next) {
  return flatDiff(this.props, next);
}

function sideEffect(Component) {
  let createClass;
  createClass = classFactory(Component);
  return handleChange => {
    let instances, emitChange;
    instances = [];

    emitChange = () => handleChange(instances.map(it => it.props));

    return createClass({
      componentWillMount: function () {
        instances.push(this);
        emitChange();
      },
      shouldComponentUpdate: hasChanges,
      componentDidUpdate: emitChange,
      componentWillUnmount: function () {
        instances.splice(instances.indexOf(this), 1);
        emitChange();
      },
      render: renderEmpty
    });
  };
}

export { handleActions, sideEffect, classFactory, link };
export default link;
//# sourceMappingURL=linking.esm.js.map
